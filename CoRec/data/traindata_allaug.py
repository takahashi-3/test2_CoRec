import numpy as npimport csvdef isLineEmpty(line):    return len(line.strip()) < 1# for 'respectively' augmentationdef respSentenceAug(words, ctags, tags):    cross_c = False    fst_conj = []    snd_conj = []    ssid = -1    sid = -1    eid = -1    conj_sid = -1    conj_eid = -1    output_words, output_ctags, output_tags = [], [], []        # beginning part    for i1 in range(0, len(words)):        if tags[i1] == 'B-before':            ssid = i1            break        else:            output_words.append(words[i1])            output_ctags.append(ctags[i1])            output_tags.append(tags[i1])          # 1st conj    for j in range(ssid, len(words)):        if tags[j] == 'B-before':                if cross_c == True:                cross_c = False                eid = j - 1                fst_conj.append([sid, eid])                ssid = j                break            else:                    eid = j - 1                if j != ssid:                    fst_conj.append([sid, eid])                sid = j                elif tags[j] == 'C':            if cross_c == False:                cross_c = True                eid = j - 1                conj_sid = j                fst_conj.append([sid, eid])                                elif tags[j] == 'B-after':            conj_eid = j - 1            fst_conj.append([conj_sid, conj_eid])             sid = j                elif tags[j] == 'O':            cross_c = False            eid = j - 1            fst_conj.append([sid, eid])            ssid = j            break    sid = -1    eid = -1    conj_sid = -1    conj_eid = -1        # 2nd conj    for j2 in range(ssid, len(words)):        if tags[j2] == 'B-before':             eid = j2 - 1            if sid != -1:                snd_conj.append([sid, eid])            sid = j2                elif tags[j2] == 'C':            # reach respectively            if words[j2] == '[C]':                eid = j2 - 1                snd_conj.append([sid, eid])                break            if cross_c == False:                cross_c = True                eid = j2 - 1                conj_sid = j2                snd_conj.append([sid, eid])                                elif tags[j2] == 'B-after':            conj_eid = j2 - 1            snd_conj.append([conj_sid, conj_eid])             sid = j2                elif tags[j2] == 'O':            if cross_c == True:                eid = j2 - 1                snd_conj.append([sid, eid])                break            # shuffle1    len_f = len(fst_conj)    len_s = len(snd_conj)        for b in range(fst_conj[len_f-1][0], fst_conj[len_f-1][1]+1):        output_words.append(words[b])        output_ctags.append(ctags[b])        if tags[b] == 'B-after':            output_tags.append('B-before')        else:            output_tags.append('I-before')            for m in range(fst_conj[len_f-2][0], fst_conj[len_f-2][1]+1):        output_words.append(words[m])        output_ctags.append(ctags[m])        output_tags.append(tags[m])            for e in range(fst_conj[0][0], fst_conj[0][1]+1):        output_words.append(words[e])        output_ctags.append(ctags[e])        if tags[e] == 'B-before':            output_tags.append('B-after')        else:            output_tags.append('I-after')        # middle       for k in range(fst_conj[len_f-1][1]+1, snd_conj[0][0]):        output_words.append(words[k])        output_ctags.append(ctags[k])        output_tags.append(tags[k])                           # shuffle2    for b2 in range(snd_conj[len_s-1][0], snd_conj[len_s-1][1]+1):        output_words.append(words[b2])        output_ctags.append(ctags[b2])        if tags[b2] == 'B-after':            output_tags.append('B-before')        else:            output_tags.append('I-before')            for m2 in range(snd_conj[len_s-2][0], snd_conj[len_s-2][1]+1):        output_words.append(words[m2])        output_ctags.append(ctags[m2])        output_tags.append(tags[m2])            for e2 in range(snd_conj[0][0], snd_conj[0][1]+1):        output_words.append(words[e2])        output_ctags.append(ctags[e2])        if tags[e2] == 'B-before':            output_tags.append('B-after')        else:            output_tags.append('I-after')        # ending part    for k2 in range(snd_conj[len_s-1][1]+1, len(words)):        output_words.append(words[k2])        output_ctags.append(ctags[k2])        output_tags.append(tags[k2])             return output_words, output_ctags, output_tags# for other sentences augmentationdef sentenceAug(words, ctags, tags):    cross_c = False    fst_conj = []    ssid = -1    sid = -1    eid = -1    conj_sid = -1    conj_eid = -1    output_words, output_ctags, output_tags = [], [], []        # beginning part    for i1 in range(0, len(words)):        if tags[i1] == 'B-before':            ssid = i1            break        else:            output_words.append(words[i1])            output_ctags.append(ctags[i1])            output_tags.append(tags[i1])        # not a complete coordinated structure    if ssid == -1:        return [], [], []                    for j in range(ssid, len(words)):        if tags[j] == 'B-before':                if cross_c == True:                cross_c = False                eid = j - 1                fst_conj.append([sid, eid])                ssid = j                break            else:                    eid = j - 1                if j != ssid:                    fst_conj.append([sid, eid])                sid = j                elif tags[j] == 'C':            if cross_c == False:                cross_c = True                eid = j - 1                conj_sid = j                fst_conj.append([sid, eid])                                elif tags[j] == 'B-after':            conj_eid = j - 1            fst_conj.append([conj_sid, conj_eid])             sid = j                elif tags[j] == 'O':            cross_c = False            eid = j - 1            fst_conj.append([sid, eid])            #ssid = j            break           # shuffle    len_f = len(fst_conj)        for b in range(fst_conj[len_f-1][0], fst_conj[len_f-1][1]+1):        output_words.append(words[b])        output_ctags.append(ctags[b])        if tags[b] == 'B-after':            output_tags.append('B-before')        else:            output_tags.append('I-before')            for m in range(fst_conj[len_f-2][0], fst_conj[len_f-2][1]+1):        output_words.append(words[m])        output_ctags.append(ctags[m])        output_tags.append(tags[m])            for e in range(fst_conj[0][0], fst_conj[0][1]+1):        output_words.append(words[e])        output_ctags.append(ctags[e])        if tags[e] == 'B-before':            output_tags.append('B-after')        else:            output_tags.append('I-after')        # ending part       for k in range(fst_conj[len_f-1][1]+1, len(words)):        output_words.append(words[k])        output_ctags.append(ctags[k])        output_tags.append(tags[k])             return output_words, output_ctags, output_tags        # if the text contain commadef lsProc(ls):    outls = []    if len(ls) == 6:        outls.append(ls[0])        outls.append(",")        outls.append(ls[3])        outls.append(ls[4])        outls.append(ls[5])        return outls    inF = open("wsj_train_new.csv", "r")outF = open("wsj_train_allaug.csv", "w")#inF = open("wsj_dev_new.csv", "r")#outF = open("wsj_dev_allaug.csv", "w")#inF = open("wsj_small_test.csv", "r")#outF = open("wsj_small_aug.csv", "w")fieldnames = ['Sentence #', 'Text', 'c-Tag', 'Tag']writer = csv.DictWriter(outF, fieldnames=fieldnames)writer.writeheader()Lines = inF.readlines()inF.close()t = []sNums, words, ctags, tags = [], [], [], []cur_sNum = ""isRespectively = Falsesentence_cnt = 1i = 1while(i < len(Lines)):    ls = Lines[i].split(',')    if len(ls) != 5:        ls = lsProc(ls)    cur_sNum = ls[0]        # a new sentence    if len(sNums) != 0 and cur_sNum != sNums[0]:        sstr = "Sentence: " + str(sentence_cnt)        for k in range (0, len(words)):            writer.writerow({'Sentence #': sstr, 'Text': words[k], 'c-Tag': ctags[k], 'Tag': tags[k]})          sentence_cnt += 1                if isRespectively == True:            output_words, output_ctags, output_tags = respSentenceAug(words, ctags, tags)            sstr = "Sentence: " + str(sentence_cnt)            for j in range (0, len(output_words)):                     writer.writerow({'Sentence #': sstr, 'Text': output_words[j], 'c-Tag': output_ctags[j], 'Tag': output_tags[j]})            sentence_cnt += 1                else:            output_words, output_ctags, output_tags = sentenceAug(words, ctags, tags)            if len(output_words) != 0:                sstr = "Sentence: " + str(sentence_cnt)                for j in range (0, len(output_words)):                         writer.writerow({'Sentence #': sstr, 'Text': output_words[j], 'c-Tag': output_ctags[j], 'Tag': output_tags[j]})                sentence_cnt += 1                sNums, words, ctags, tags = [], [], [], []        isRespectively = False        sNums.append(ls[0])    lw = len(words)    if lw > 0 and words[lw-1] == '[C]':        if ls[1] == 'respectively':            isRespectively = True         words.append(ls[1])    ctags.append(ls[2])    tags.append(ls[4].rstrip('\n'))      i += 1        # last sentence    if i == len(Lines):        sstr = "Sentence: " + str(sentence_cnt)        for w in range (0, len(words)):            writer.writerow({'Sentence #': sstr, 'Text': words[w], 'c-Tag': ctags[w], 'Tag': tags[w]})              print(sentence_cnt)    outF.close()